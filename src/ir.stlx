load("util.stlx");
load("parser.stlx");

class inst(id, data, start, end) {
	id        := id;
	data      := data;
	start     := start;
	end       := end;
	className := procedure() { return "inst"; };
	is        := procedure(x) { return id == x; };
	displayStr := procedure() {
		res := om;
		if (data == om) {
			res := id;
		} else {
			res := id + "('" + data + "')";
		}
		return res;
	};
	toStr := displayStr;
}

class proc(name, args, vars, code, start, end) {
	name      := name;
	args      := args;
	vars      := vars;
	code      := code;
	start     := start;
	end       := end;
	className := procedure() { return "proc"; };
	displayStr := procedure() {
		s := name;
		if (#args > 0) { s += " (\n\t" + join([arg.displayStr() : arg in args], "\n\t") + "\n)"; }
		else { s += " ()"; }
		if (#code > 0) { s += " {\n\t" + join([inst.displayStr() : inst in code], "\n\t") + "\n}"; }
		else { s += " {}"; }
		return s;
	};
	toStr := displayStr;
}

class intermediateRep(procs := [], vars := [], code := []) {
	procs := procs;
	vars  := vars;
	code  := code;
	className := procedure() { return "intermediateRep"; };
	displayStr := procedure() {
		s := "Procedures:";
		for (proc in procs) { s += "\n" + proc.displayStr(); }
		s += "\nVariables:";
		for (var  in vars)  { s += "\n" + var.displayStr(); }
		s += "\nCode:";
		for (c    in code)  { s += "\n" + c.displayStr(); }
		return s;
	};
	toStr := displayStr;
}

pointAdd := procedure(a, b) {
	return [
		a[1] + b[1],
		a[2] + b[2]
	];
};

// Returns array with 2 elements
// First a list of IR instructions, then a set of variables, that was used in the expression
codegenExpr := procedure(file, node) {
	global.push("codegenExpr", [["ast", node.displayStr()]]);
	res := [[], {}];
	// global.p("codegenExpr - node: " + node.id);
	match(node.id) {
		case "BinOp":
			res := pointAdd(res, codegenExpr(file, node.args[1]));
			res := pointAdd(res, codegenExpr(file, node.args[2]));
			op  := node.data;
			if (op == "AddColl" || op == "MulColl") { op += "Bin"; }
			res[1] += [inst(op, om, node.start, node.end)];
		case "UnaryOp":
			res := pointAdd(res, codegenExpr(file, node.args[1]));
			op  := node.data;
			if      (op == "Sub")  { op := "Neg"; }
			else if (op == "Hash") { op := "Len"; }
			res[1] += [inst(op, om, node.start, node.end)];
		case "Call":
			for (arg in node.args) {
				res := pointAdd(res, codegenExpr(file, arg));
			}
			res[1] += [inst("Int", #node.args, node.start, node.end)];
			res[1] += [inst("Var", node.data.data, node.start, node.end)];
			res[1] += [inst("Call", om, node.start, node.end)];
		case "Property":
			res := pointAdd(res, codegenExpr(file, node.data));
			res := pointAdd(res, codegenExpr(file, node.args[1]));
		case "Index":
			if (node.args[2].id == "Range") {
				res := pointAdd(res, codegenExpr(file, node.args[2]));
			} else {
				res    := pointAdd(res, codegenExpr(file, node.args[1]));
				res    := pointAdd(res, codegenExpr(file, node.args[2]));
				res[1] += [inst("Index", om, node.start, node.end)];
			}
		case "Range":
			list := codegenExpr(file, node.args[1]);
			res  := pointAdd(res, list);
			if (node.args[2] == om) {
				res[1] += [inst("Int", 1, node.args[1].end, node.args[1].end)];
			} else {
				res := pointAdd(res, codegenExpr(file, node.args[2]));
			}
			if (node.args[3] == om) {
				res    := pointAdd(res, list);
				res[1] += [inst("Len", om, node.end, node.end)];
			} else {
				res := pointAdd(res, codegenExpr(file, node.args[3]));
			}
			res[1] += [inst("Range", om, node.start, node.end)];
		case "List":
			for (expr in node.args) {
				res := pointAdd(res, codegenExpr(file, expr));
			}
			res[1] += [inst("Int", #node.args, node.start, node.end)];
			res[1] += [inst(node.id, om, node.start, node.end)];
		case "Set":
			for (expr in node.args) {
				res := pointAdd(res, codegenExpr(file, expr));
			}
			res[1] += [inst("Int", #node.args, node.start, node.end)];
			res[1] += [inst(node.id, om, node.start, node.end)];
		case "Str":
			res[1] += [inst("Str", node.data, node.start, node.end)];
		case "Float":
			res[1] += [inst(node.id, node.data, node.start, node.end)];
		case "Int":
			res[1] += [inst(node.id, node.data, node.start, node.end)];
		case "Bool":
			res[1] += [inst(node.id, node.data, node.start, node.end)];
		case "Iden":
			res[1] += [inst("Var", node.data, node.start, node.end)];
			res[2] += {node.data};
		default:
			compileErr(file, node.start, node.end, "Encountered unexpected node in codegenExpr: " + node.id);
	}
	global.pop();
	return res;
};

// @Note: Returns a 2D array of instructions. Each instruction is a list containing a 'Var' and optionally also an 'Assign' instruction (including all the instructions for the assignment).
// @Note: If 'flatList' is true, the return value is a flat 1D list of the same instructions instead
codegenArgList := procedure(file, ast, flatList := false) {
	global.push("codegenArgList", [["ast", ast.displayStr()], ["flatList", flatList]]);
	if (!ast.is("ArgList")) { stop("Start Assumption of codegenArgList broken. Expects ast to be a ArgList, but received a " + ast.id + " instead."); }

	res := [];
	for (node in ast.args) {
		insts := [];
		match(node.id) {
			case "Iden"  : insts += codegenExpr(file, node)[1];
			case "Assign": insts += codegenAssign(file, node)[1]; // @Study: Could a procedure be assigned here?
			default      : compileErr(file, node.start, node.end, "Encountered unexpected node in codegenArgList: " + node.id);
		}
		if (flatList) { res += insts;   }
		else          { res += [insts]; }
	}

	global.pop();
	return res;
};

// Returns an array with 2 or 3 elements
// 1. List of IR instructions
// 2. Set of variable names used in statement
// 3. Procedure that was defined (potentially empty)
codegenAssign := procedure(file, node) {
	global.push("codegenAssign", [["node", node.displayStr()]]);
	if (!node.is("Assign")) { stop("Start Assumption of codegenAssign broken. Expects node to be a Assign, but received a " + node.id + " instead."); }

	res := [[], {}];
	if (node.args[2].id == "Proc") {
		proc   := codegenProc(file, node.args[2], node.args[1].data);
		res    += proc;
		res[1] += [inst("Proc", proc.name, proc.start, proc.end)];
	} else {
		res := pointAdd(res, codegenExpr(file, node.args[2]));
	}
	res    := pointAdd(res, codegenExpr(file, node.args[1]));
	res[1] += [inst("Assign", om, node.start, node.end)];

	global.pop();
	return res;
};

codegenProc := procedure(file, node, proc_name := om) {
	compileErr(file, node.start, node.end, "Codegen for Procedures is not yet implemented");
	// @TODO:
	// [ir.code, vars] := codegenBlock(file, node.args[2]);
	// p := proc(currentVarName)
	// ir.procs += [p];
	// currentVarName = om;
};

getVarInits := procedure(vars := {}) {
	res := [];
	for (var in vars) {
		res += [inst("Om", om, 0, 0), inst("Var", var, 0, 0), inst("Assign", om, 0, 0)];
	}
	return res;
};

// Generate an intermediateRep object for a block of code
codegenBlock := procedure(file, ast) {
	global.push("codegenBlock", [["file", file], ["ast", ast.displayStr()]]);
	if (!ast.is("Block")) { stop("Start Assumption of codegenBlock broken. Expects ast to be a Block, but received a " + ast.id + " instead."); }

	ir             := intermediateRep();
	vars           := {};
	currentVarName := om;

	for (node in ast.args) {
		// global.p("codegenBlock - node: " + node.id);
		match(node.id) {
			case "Block":
				block    := codegenBlock(file, node);
				ir.code  += block[1].code;
				ir.procs += block[1].procs;
				vars     += block[2];
			case "Ret":
				expr    := codegenExpr(file, node.args[1]);
				ir.code += expr[1];
				vars    += expr[2];
				ir.code += [inst("Ret", om, node.start, node.end)];
			case "Assign":
				t       := codegenAssign(file, node);
				ir.code += t[1];
				vars    += t[2];
				if (#t == 3) { ir.procs += [t[3]]; }
			case "ArgList":
				// @TODO: This is probably not correct, because ir.code should be a 1D list and codegenArgList returns a 2D List here...
				ir.code += codegenArgList(file, node);
			case "Proc":
				// If the Proc appears here, it is never assigned and can thus never be called
				// We can therefore safely ignore the procedure
				// ir.procs += codegenProc(file, node);
			case "If":
				label        := global.labelCounter.get();
				body         := codegenBlock(file, node.args[2]);
				body[1].code += [inst("Label", label, node.end, node.end)];
				vars         += body[2];

				cond     := codegenExpr(file, node.args[1]);
				vars     += cond[2];
				ir.code  += cond[1];
				ir.code  += [inst("CondJmp", label, node.start, node.end)];
				ir.code  += body[1].code;
				ir.procs += body[1].procs;
			case "Else":
				prevLabel := ir.code[#ir.code];
				ir.code   := ir.code[1..#ir.code-1];
				cond      := om;
				body      := om;
				if (#node.args == 2) {
					[cond, body] := node.args;
				} else {
					body := node.args[1];
				}
				body         := codegenBlock(file, body);
				vars         += body[2];
				label        := global.labelCounter.get();
				body[1].code += [inst("Label", label, node.end, node.end)];
				ir.code      += [inst("Jmp", label, node.start, node.end)];
				ir.code      += [prevLabel];
				if (cond != om) {
					cond    := codegenExpr(file, cond);
					vars    += cond[2];
					ir.code += cond[1];
					ir.code += [inst("CondJmp", label, node.start, node.end)];
				}
				ir.code  += body[1].code;
				ir.procs += body[1].procs;
			case "Class":
				compileErr(file, node.start, node.end, "Codegen for Classes is not yet implemented");
			case "Static":
				compileErr(file, node.start, node.end, "Codegen for Static blocks is not yet implemented");
			case "For":
				compileErr(file, node.start, node.end, "Codegen for For-Loops is not yet implemented");
			case "While":
				compileErr(file, node.start, node.end, "Codegen for While-Loops is not yet implemented");
			case "DoWhile":
				compileErr(file, node.start, node.end, "Codegen for DoWhile-Loops is not yet implemented");
			default:
				expr    := codegenExpr(file, node);
				ir.code += expr[1];
				vars    += expr[2];
		}
	}

	global.pop();
	return [ir, vars];
};

codegen := procedure(file, ast) {
	[ir, vars] := codegenBlock(file, ast);
	ir.code := getVarInits(vars) + ir.code;
	return ir;
};