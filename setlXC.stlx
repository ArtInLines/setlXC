// stackNode is used to create a Stack-trace for debugging the compiler
// @Note: This is actually a tree, since I have found myself wanting to get information about past snapshots of the stack-trace as well
// However, calling toStr() prints the stackNode as though it actually was a stack
class stackNode(n, args) {
	this.name     := n;
	this.args     := args; // List of argument-tuples (names, values) @Note: values must also be provided as strings
	this.children := []; // List of children nodes
	argsToStr := procedure() {
		if (#this.args == 0) { return ""; }
		s := "(";
		for (arg in args) {
			s += arg[1] + ": " + arg[2] + ", ";
		}
		idx := #s - 2;
		return s[1..idx] + ")";
	};
	// Get a string representation of the stack over time (meaning in tree-representation)
	toFullStr := procedure(in_level := 0, in_str := "  ") {
		s := in_str * in_level;
		s += this.name;
		for (c in this.children) {
			s += "\n" + c.toFullStr(in_level + 1, in_str);
		}
		return s;
	};
	// Get a string representation of the current stack
	toStr := procedure() {
		s := this.name + " " + this.argsToStr();
		node := this;
		while (node.children != []) {
			node := node.children[#node.children];
			s += "\n" + node.name + " " + node.argsToStr();
		}
		return s;
	};
	// Get the node at level x
	get := procedure(x := 1) {
		if (x <= 1) { return this; }
		else if (this.children == []) { throw("Error in getting StackNode"); }
		else { return this.children[#this.children].get(x - 1); }
	};
	// Add a new node to level x
	add := procedure(n, args := {}, x := 0) {
		if (x <= 0) { this.children += [stackNode(n, args)]; }
		else if (this.children == []) { throw("Error in adding to stackNode"); }
		else { this.children[#children] := this.children[#children].add(n, args, x - 1); }
		return this;
	};
}

setToStr := procedure(set, f := om) {
	if (f == om) { return "" + {   x  : x in set }; }
	else         { return "" + { f(x) : x in set }; }
};

listToStr := procedure(list, f := om) {
	if (f == om) { return "" + [   x  : x in list ]; }
	else         { return "" + [ f(x) : x in list ]; }
};

class global() {
	static {
		debug := false;
		p := procedure(s) {
			if (global.debug) { print(s); }
		};

		stack := om;
		stacklen := 0;
		push := procedure(name, args := []) {
			if (global.stack == om) { global.stack := stackNode(name, args); }
			else { global.stack := global.stack.add(name, args, global.stacklen - 1); }
			global.stacklen += 1;
		};
		pop := procedure() {
			global.stacklen -= 1;
		};

		keywordsToToks := {
			["class", "Class"],
			["static", "Static"],
			["in", "In"],
			["notin", "Notin"],
			["return", "Ret"],
			["procedure", "Proc"],
			["cachedProcedure", "CachedProc"],
			["try", "Try"],
			["catch", "Catch"],
			["if", "If"],
			["else", "Else"],
			["for", "For"],
			["while", "While"],
			["do", "Do"]
		};

		symbolsToToks := [
			["(", "LParan"],
			[")", "RParan"],
			["[", "LBrack"],
			["]", "RBrack"],
			["{", "LCurly"],
			["}", "RCurly"],
			["|->", "Lambda"],
			["|=>", "ScopedLambda"], // TODO: Rename
			["<==>", "Equiv"],
			["<!=>", "Xor"],
			["=>", "Entail"],
			["||", "Or"],
			["&&", "And"],
			[":=", "Assign"],
			["==", "Eq"],
			["!=", "Ne"],
			["<=", "Le"],
			[">=", "Ge"],
			["<", "Lt"],
			[">", "Gt"],
			["!", "Not"],
			["**", "Exp"],
			["+/", "AddColl"],
			["*/", "MulColl"],
			["><", "CartProd"],
			["+=", "AddAssign"],
			["-=", "SubAssign"],
			["*=", "MulAssign"],
			["/=", "DivAssign"],
			["%=", "ModAssign"],
			['\=', "IntDivAssign"],
			["+", "Add"],
			["-", "Sub"],
			["*", "Mul"],
			["/", "Div"],
			["%", "Mod"],
			['\', "IntDiv"],
			["#", "Hash"],
			[",", "Comma"],
			[";", "SemiColon"],
			[":", "Colon"],
			["..", "DotDot"],
			[".", "Dot"]
		];

		assignToks := ["Assign", "AddAssign", "SubAssign", "MulAssign", "DivAssign", "ModAssign", "IntDivAssign"];

		unaryOps := ["AddColl", "MulColl", "Sub", "Add", "Not", "Hash"];

		// The higher the precedence, the earlier the operation is evaluated
		binOpPrecs := {
			["Equiv", 20],
			["Xor", 20],
			["Entail", 31],
			["Or", 32],
			["And", 33],
			["Le", 35],
			["Ge", 35],
			["Lt", 35],
			["Gt", 35],
			["In", 35],
			["Notin", 35],
			["Eq", 35],
			["Ne", 35],
			["Add", 40],
			["Sub", 40],
			["Mul", 50],
			["Div", 50],
			["Mod", 50],
			["IntDiv", 50],
			["CartProd", 50],
			["AddColl", 60],
			["MulColl", 60],
			["Exp", 90]
		};

		isRightAssoc := procedure(toktype) {
			return toktype in { "Exp", "Assign", "AddAssign", "SubAssign", "MulAssign", "DivAssign", "ModAssign", "IntDivAssign" };
		};
	}
}

class loc(file, row, col) {
	file := file;
	row  := row;
	col  := col;
	className := procedure() { return "loc"; };
	equals    := procedure(other) { return other != om && file == other.file && row == other.row && col == other.col; };
	locStr    := procedure() { return file + ":" + row + ":" + col; };
	toStr     := locStr;

	static {
		toStr := procedure(start, end) {
			if (start.file != end.file) { throw("loc.toStr(start, end) doesn't work if `start` and `end` are locations in different files"); }
			lines := readFile(start.file, [start.row..end.row]);
			if (start.row == end.row) {
				lines[1] := lines[1][start.col..end.col];
			} else {
				lines[1] := lines[1][start.col..];
				lines[-1] := lines[-1][..end.col];
			}
			return join(lines, "\n");
		};
	}
}

class token(type, start, end, data := om) {
	type  := type;
	start := start;
	end   := end;
	data  := data;
	className  := procedure() { return "token"; };
	is         := procedure(typ) { return type == typ; };
	// @Note: Primary values are literals or paranthesized expressions
	isPrimary  := procedure() { return type in {"Iden", "Str", "Int", "Float", "LParan", "LBrack", "LCurly"}; };
	equals     := procedure(other) { return other != om && type == other.type && start == other.start && end == other.end && data == other.data; };
	displayStr := procedure() {
		if (data == om) {
			return type;
		} else {
			return type + "('" + data + "')";
		}
	};
	toStr      := displayStr;
}

class astNode(type, start, end, data := om, args := [], body := []) {
	type  := type;
	start := start;
	end   := end;
	data  := data;
	args  := args;
	body  := body;
	className := procedure() { return "astNode"; };
	is        := procedure(typ) { return type == typ; };
	equals    := procedure(other) { return other != om && type == other.type && start == other.start && end == other.end && data == other.data; }; // Not checking children for equality for performance reasons
	dataToStr := procedure() {
		dat := data;
		if (data != om && isObject(data) && data.className() == "astNode") { dat := dat.displayStr(); }
		return dat;
	};
	dumpToStr := procedure(show_loc := false, indent_level := 0, single_indent := " ") {
		s := single_indent * indent_level + "@" + type;
		if (data != om) { s += "('" + dataToStr() + "')"; }
		if (show_loc) { s += " [" + start.locStr() + " - " + end.locStr() + "]"; }

		if (#args > 0 && #body > 0) { s += "\n" + single_indent * (indent_level + 1) + "Args:"; }
		for (c in args) { s += "\n" + c.dumpToStr(show_loc, indent_level + 2, single_indent); }
		if (#body > 0) { s += "\n" + single_indent * (indent_level + 1) + "Body:"; }
		for (stmt in body) { s += "\n" + stmt.dumpToStr(show_loc, indent_level + 2, single_indent); }
		return s;
	};
	displayStr := procedure() {
		if (data ==  om) {
			return "@" + type;
		}
		return "@" + type + "(" + dataToStr() + ")";
	}; // for compatibility with token-class
	toStr := displayStr;
}



compileErr := procedure(file, start, endOrLocStr, msg) {
	printErr(msg + ":");
	locStr := endOrLocStr;
	if (isObject(endOrLocStr)) { locStr := loc.toStr(start, endOrLocStr); }
	printErr(start.locStr() + ": '" + locStr + "'");
	throw("Compiler Error");
};

startsWith := procedure(str, prefix, strOffset := 0) {
	if (#str - strOffset < #prefix) {
		return false;
	}
	for (i in {1..#prefix}) {
		if (str[strOffset + i] != prefix[i]) {
			return false;
		}
	}
	return true;
};

class lexer(file_path, str) {
	file := file_path;
	str  := str;
	cur  := 1;
	bol  := 0;
	lc   := 1;
	len  := #str;
	className := procedure() { return "lexer"; };

	is_space := procedure(c := str[cur]) {
		return c == " " || c == "\t" || c == "\n" || c == "\r";
	};

	is_newline := procedure(c := str[cur]) {
		return c == "\n";
	};

	chop_char := procedure() {
		if (is_newline()) {
			this.bol := this.cur;
			this.lc += 1;
		}
		this.cur += 1;
	};

	chop_lc := procedure() {
		// Line Comment
		if(str[cur..cur+1] != "//") { throw("chop_lc should only be called when str[cur..cur+1] == '//' is true"); }
		this.cur += 2;
		while (cur <= len && !is_newline(str[cur])) {
			chop_char();
		}
	};

	chop_bc := procedure() {
		// Block Comment
		start_cur := cur;
		start := loc(file, lc,start_cur - bol);
		if(str[cur..cur+1] != "/*") { throw("chop_bc should only be called when str[cur..cur+1] == '/*' is true"); }
		this.cur += 2;
		while (cur <= len) {
			// Return from function, when block comment is over
			if (cur < len && str[cur..cur+1] == "*/") {
				this.cur += 2;
				return om;
			}
			chop_char();
		}
		compileErr(file, start, str[start_cur..cur], "Unclosed Block Comment");
	};

	next_word := procedure() {
		start := cur;
		s := str[cur];
		this.cur += 1;
		while (cur < len && matches(str[cur], '[a-zA-Z_0-9]')) {
			s += str[cur];
			chop_char();
		}

		start := loc(file, lc,start - bol);
		end := loc(file, lc,cur - bol);
		if (s in domain(global.keywordsToToks)) {
			return token(global.keywordsToToks[s], start, end);
		} else {
			return token("Iden", start, end, s);
		}
	};

	next_num := procedure() {
		start := cur;
		s := str[cur];
		this.cur += 1;
		isFloat := false;
		while (cur < len && matches(str[cur], '[0-9.]')) {
			if (str[cur] == '.') {
				// The dot is here to start a range, not to make a float
				if (str[cur+1] == '.') { break; }
				if (isFloat) { compileErr(file, loc(file, lc,start - bol), str[start..cur], "Only one '.' is allowed for numbers."); }
				isFloat := true;
			}
			s += str[cur];
			chop_char();
		}

		start := loc(file, lc,start - bol);
		end := loc(file, lc, cur - bol);
		if (isFloat) {
			return token("Float", start, end, s);
		} else {
			return token("Int", start, end, s);
		}
	};

	next_symbol := procedure() {
		start := cur;
		for([sym, tok] in global.symbolsToToks) {
			if (startsWith(str, sym, cur - 1)) {
				this.cur += #sym;
				return token(tok, loc(file, lc, start - bol), loc(file, lc, cur - bol));
			}
		}
		compileErr(file, loc(file, lc,start - bol), str[start], "Unknown Symbol");
	};

	next_str := procedure() {
		start := loc(file, lc,cur - bol);
		strDelim := str[cur];
		this.cur += 1;
		s := "";
		while (cur < len && str[cur] != strDelim) {
			if (strDelim == '"' && str[cur] == '\') {
				chop_char();
				if (cur > len) { break; }
				match (str[cur]) {
					// List of escape-chars: https://docs.oracle.com/javase/tutorial/java/data/characters.html
					regex 't': s += "\t";
					regex 'b': s += "\b";
					regex 'n': s += "\n";
					regex 'r': s += "\r";
					regex 'f': s += "\f";
					regex '"': s += '"';
					regex "'": s += "'";
					regex '\\': s += '\';
					default: return compileErr(file, start, s + '\' + str[cur], "Invalid Escape Character '" + str[cur] + "'");
				}
			} else {
				s += str[cur];
			}
			chop_char();
		}

		if (cur > len) {
			return compileErr(file, start, loc(file, lc,cur - bol), strDelim + s, "Unclosed String");
		}
		assert(str[cur] == strDelim, "At the end of the while-loop, it is expected that `str[cur] == strEnd` is true, unless the string is unclosed");
		chop_char();
		end := loc(file, lc,cur - bol);
		return token("Str", start, end, s);
	};

	next_token := procedure() {
		// global.p("next_token  -  cur=" + cur + ", str[cur]=" + str[cur]);
		while(cur <= len && is_space()) {
			chop_char();
		}
		if (cur > len) {
			return om;
		}
		if (matches(str[cur], '[a-zA-Z_]')) { return next_word();   }
		else if (matches(str[cur], '[0-9]')) { return next_num();    }
		else if (str[cur] == '"') { return next_str(); }
		else if (str[cur] == "'") { return next_str(); }
		else if (cur < len && str[cur..cur+1] == "//") {
			chop_lc();
			return next_token();
		}
		else if (cur < len && str[cur..cur+1] == "/*") {
			chop_bc();
			return next_token();
		}
		else { return next_symbol(); }
	};

	lex := procedure() {
		toks := [];
		t := next_token();
		while (t != om) {
			toks += [t];
			t := next_token();
		}
		return toks;
	};
}

class parser(file_path, toks) {
	file := file_path;
	toks := toks;
	len  := #toks;
	idx  := 1;
	className := procedure() { return "parser"; };

	cur_tok := procedure() {
		return toks[idx];
	};

	chop_tok := procedure() {
		if (idx > len) {
			compileErr(file, toks[-1].start, toks[-1].end, "Unexpected End of File.");
		}
		t := toks[idx];
		this.idx += 1;
		return t;
	};

	get_tok_prec := procedure() {
		if (toks[idx] in domain(global.binOpPrecs)) {
			return global.binOpPrecs[toks[idx]];
		} else {
			return -1;
		}
	};

	parse := procedure() {
		global.push("parse");
		if (len == 0) {
			return astNode("Block", 0, 0);
		}

		stmts := [];
		while (idx <= len) {
			stmts += [parseStmt({["Class", [] |=> parseClass()]})];
		}
		global.pop();
		return astNode("Block", toks[1].start, toks[-1].end, om, stmts);
	};

	parseStmt := procedure(additionalCases := {}, invalidCases := {}) {
		global.push("parseStmt", [["additionalCases", setToStr(additionalCases, x |=> x[1])], ["invalidCases", setToStr(invalidCases, x |=> x[1])]]);
		t := chop_tok();
		res := om;
		// global.p("parseStmt - t: " + t.toStr() + ", cur_tok(): " + cur_tok().toStr());
		switch {
			case t.type in domain(invalidCases):    res := compileErr(file, t.start, t.end, invalidCases[t.type]);
			case t.type in domain(additionalCases): res := additionalCases[t.type]();
			case t.is('If'):        res := parseIf();
			case t.is('Else'):      res := parseElse();
			case t.is('Match'):     res := parseMatch();
			case t.is("Switch"):    res := parseSwitch();
			case t.is("Try"):       res := parseTry();
			case t.is("Scan"):      res := parseScan();
			case t.is("For"):       res := parseFor();
			case t.is("While"):     res := parseWhile();
			case t.is("Do"):        res := parseDoWhile();
			case t.is("Check"):     res := parseCheck();
			case t.is("Backtrack"): res := parseBacktrack();
			case t.is("Ret"):
				expr := parseExprWithEndTok(chop_tok(), "SemiColon");
				res := astNode("Ret", t.start, toks[idx-1].end, om, [expr]);
			case t.isPrimary(): res := parseExprOrAssignWithEndTok(t, "SemiColon");
			default: compileErr(file, t.start, t.end, "Invalid Token starting Statement: " + t.displayStr());
		}
		// global.p("parsed stmt: " + res.displayStr());
		global.pop();
		return res;
	};

	// Starts with t == toks[idx-1] == first token of expression/assignment
	// Expects t to be a primary token as well
	// Ends after token of endTokTypes
	// @Name is very long but at least descriptive???
	parseExprOrAssignWithEndTok := procedure(t, endTokTypes) {
		if (!isList(endTokTypes)) { endTokTypes := [endTokTypes]; }
		global.push("parseExprOrAssignWithEndTok", [["t", t.toStr()], ["endTokTypes", listToStr(endTokTypes)]]);
		if (!t.isPrimary()) { stop("parseExprOrAssignWithEndTok - start assumption broken"); }

		res := parseExprWithEndTok(t, endTokTypes + global.assignToks);
		if (toks[idx-1].type in global.assignToks) {
			assignTok := toks[idx-1];
			if (res.type notin {"Iden", "Index", "Property"}) {
				compileErr(file, res.start, assignTok.end, "Expected an identifier before assignment. Found a " + res.displayStr() + " instead");
			}
			val := parseExprWithEndTok(chop_tok(), endTokTypes);
			if (assignTok.type != "Assign") {
				bin_op_typ := assignTok.type[..-7]; // -7 comes from `- #"Assign" - 1`
				bin_op     := astNode("BinOp", res.start, val.end, bin_op_typ, [res, val]);
				res        := astNode("Assign", res.start, val.end, om, [res, bin_op]);
			} else {
				res := astNode("Assign", res.start, val.end, om, [res, val]);
			}
		}

		if (toks[idx-1].type notin endTokTypes) { stop("parseExprOrAssignWithEndTok: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with first token of expr or astNode
	// Ends after token of endTokTypes
	parseExprWithEndTok := procedure(t, endTokTypes) {
		if (!isList(endTokTypes)) { endTokTypes := [endTokTypes]; }
		global.push("parseExprWithEndTok", [["t", t.toStr()], ["endTokTypes", listToStr(endTokTypes)]]);
		if (idx > len) {
			compileErr(file, t.start, t.end, "Unexpected End of File. Expected a ';'");
		}
		nt := chop_tok();
		// global.p("exprWithEndTok - t: " + t.displayStr());
		// global.p("exprWithEndTok - nt: " + nt.displayStr());
		// global.p("exprWithEndTok - endTokTypes: " + endTokTypes);

		res := om;
		switch {
			case nt.type in endTokTypes:
				if (t.className() != "astNode") {
					this.idx -= 1;
					res := parsePrimary(t);
					this.idx += 1;
				} else {
					res := t;
				}
			case t.is("Proc"):
				res := parseProc(nt);
				this.idx += 1;
			case t.className() == "token" && t.type in global.unaryOps:
				this.idx -= 2;
				unary := parseUnary();
				if (idx > len && #endTokTypes > 0) {
					compileErr(file, t.start, op_ast.end, "Invalid End of File. Expected one of the following symbols: " + endTokTypes);
				}
				res := parseExprWithEndTok(unary, endTokTypes);
			case nt.type in domain(global.binOpPrecs):
				this.idx -= 1;
				op_ast := parseBinOps(t, 0);
				if (idx > len && #endTokTypes > 0) {
					compileErr(file, t.start, op_ast.end, "Invalid End of File. Expected one of the following symbols: " + endTokTypes);
				}
				res := parseExprWithEndTok(op_ast, endTokTypes);
			case t.className() == "token" && t.isPrimary():
				this.idx -= 2;
				res := parseExprWithEndTok(parsePrimary(), endTokTypes);
			case t.className() == "astNode" && nt.is("LBrack"):
				stmt := parseExprWithEndTok(chop_tok(), ["RBrack", "DotDot"]);
				if (toks[idx-1].is("DotDot")) {
					x := om;
					if (!cur_tok().is("RBrack")) { x := parseExprWithEndTok(chop_tok(), ["RBrack"]); }
					else { chop_tok(); }
					stmt := astNode("Range", t.start, toks[idx-1].end, om, [t, x]);
				}
				node := astNode("Index", t.start, toks[idx-1].end, om, [t, stmt]);
				res := parseExprWithEndTok(node, endTokTypes);
			case nt.is("LParan"):
				argList := parseCommaSeparated("RParan");
				data := t;
				if (t.className() == "token") { data := t.data; }
				call := astNode("Call", t.start, toks[idx-1].end, data, argList);
				res := parseExprWithEndTok(call, endTokTypes);
			case nt.is("Dot"):
				tt := chop_tok();
				if (!tt.is("Iden")) { compileErr(file, tt.start, loc.toStr(t.start, tt.end), "Syntax Error. Only identifiers are allowed as accessors after a dot."); }
				tt := parsePrimary(tt);
				p := t.data;
				if (t.className() == "astNode") { p := t; }
				prop := astNode("Property", t.start, tt.end, t.data, [tt]);
				res := parseExprWithEndTok(prop, endTokTypes);
			default:
				global.p("endTokTypes: " + endTokTypes);
				global.p("t.loc: " + t.start.locStr() + " - " + t.end.locStr());
				global.p("nt.loc: " + nt.start.locStr() + " - " + nt.end.locStr());
				compileErr(file, t.start, nt.end, "Unhandled case for initial token " + t.displayStr() + " and next token " + nt.displayStr() + ". This case was not implemented yet");
		}

		if (toks[idx-1].type notin endTokTypes) { stop("parseExprWithEndTok: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with toks[idx-2] == "procedure" & t == toks[idx-1]
	// End with toks[idx-1] == ending "}"
	parseProc := procedure(t := chop_tok()) {
		global.push("parseProc", [["t", t.toStr()]]);
		if (!toks[idx-2].is("Proc") || t != toks[idx-1]) { stop("parseProc: start assumption broken"); }

		start_loc := toks[idx-2].start;
		proc_format := "'procedure ( <argument>* ) { <body> }'";
		if (!t.is("LParan")) {
			compileErr(file, t.start, loc.toStr(start_loc, t.end), "Syntax Error. Procedure-Definitions should have the following format: " + proc_format);
		}
		argList := parseCommaSeparated("RParan");
		tt := chop_tok();
		if (!tt.is("LCurly")) {
			compileErr(file, tt.start, loc.toStr(start_loc, tt.end), "Syntax Error. Procedure-Definitions should have the following format: " + proc_format);
		}

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}

		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Syntax Error. Procedure-Definitions should have the following format: " + proc_format);
		}
		end_loc := chop_tok().end;
		res := astNode("Proc", start_loc, end_loc, om, argList, body);

		// global.p("parsed proc:\n" + res.dumpToStr(1));
		if (!toks[idx-1].is("RCurly")) { stop("parseProc: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with toks[idx-1] == "if"
	// Ends with toks[idx-1] == "}"
	parseIf := procedure() {
		global.push("parseIf");
		if_form := "if (<cond>) { <body> }";
		if (!toks[idx-1].is("If")) { stop("parseIf: start assumption broken"); }
		start_loc := toks[idx-1].start;

		if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: If-Satements should have the following form: " + if_form); }
		cond := parseExprWithEndTok(chop_tok(), ["RParan"]);
		if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: If-Satements should have the following form: " + if_form); }

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in If-statement");
		}

		next := chop_tok();
		end_loc := next.end;
		if (!toks[idx-1].is("RCurly")) { stop("parseIf: end assumption broken"); }
		global.pop();
		return astNode("If", start_loc, end_loc, om, [cond], body);
	};

	// Starts with toks[idx-1] == "Else"
	// Ends with toks[idx-1] == "}"
	parseElse := procedure() {
		global.push("parseElse");
		else_form := "else (if (<cond>))* { <body> }";
		if (!toks[idx-1].is("Else")) { stop("parseElse: start assumption broken"); }
		start_loc := toks[idx-1].start;

		conds := [];
		if (cur_tok().is("If")) {
			chop_tok();
			if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: Else-Satements should have the following form: " + else_form); }
			conds += [parseExprWithEndTok(chop_tok(), ["RParan"])];
			if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: Else-Satements should have the following form: " + else_form); }
		}

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in Else-statement");
		}

		next := chop_tok();
		end_loc := next.end;
		if (!toks[idx-1].is("RCurly")) { stop("parseElse: end assumption broken"); }
		global.pop();
		return astNode("Else", start_loc, end_loc, om, conds, body);
	};

	parseMatch := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseMatch` is not yet implemented");
	};

	parseSwitch := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseSwitch` is not yet implemented");
	};

	parseTry := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseTry` is not yet implemented");
	};

	// Starts with toks[idx-1] == "Class"
	// Ends with toks[idx-1] == "}"
	parseClass := procedure() {
		global.push("parseClass");
		if (!toks[idx-1].is("Class")) { stop("parseClass: start assumption broken"); }

		start_loc := toks[idx-1].start;
		class_format := 'class <name> (<arg>*) { <attributes and methods> }';
		if (idx + 5 > len) {
			compileErr(file, toks[idx-1].start, toks[-1].end, "Invalid end of file. Class-Declarations should have the following format: " + class_format);
		}
		name := chop_tok();
		if (!chop_tok().is("LParan")) {
			compileErr(file, toks[idx-1].start, loc.toStr(file, name.start, cur_tok().start), "Syntax Error. Class-Declarations should have the following format: " + class_format);
		}
		argList := parseCommaSeparated("RParan");
		if (!chop_tok().is("LCurly")) {
			compileErr(file, toks[idx-1].start, loc.toStr(file, name.start, cur_tok().start), "Syntax Error. Class-Declarations should have the following format: " + class_format);
		}
		stmts := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			stmts += [parseStmt({["Static", [] |=> parseStaticBlock()]}, {["Class", "Class-Declarations inside of class declarations are not allowed"]})];
		}
		if (idx > len) {
			compileErr(file, toks[-1].end, "class " + class_name + "(...) {... ", "Unclosed Curly Braces in Declaration of '" + class_name + "' class");
		}
		end_loc := chop_tok().end;

		if (!toks[idx-1].is("RCurly")) { stop("parseclass: end assumption broken"); }
		global.pop();
		return astNode("Class", start_loc, end_loc, class_name, argList, stmts);
	};

	// Call with toks[idx-1] == "Static"
	// Ends with toks[idx-1] == "}"
	parseStaticBlock := procedure() {
		global.push("parseStaticBlock");
		if (!toks[idx-1].is("Static")) { stop("parseStaticBlock: start assumption broken"); }

		start_loc := toks[idx-1].start;
		if (idx > len || !chop_tok().is("LCurly")) {
			compileErr(file, start_loc, "static", "Syntax Error: Expected '{ ... }' after `static` keyword.");
		}
		stmts := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			stmts += [parseStmt({}, {["Class", "Class-Declarations inside of class declarations are not allowed"]})];
		}
		if (idx > len){
			compileErr(file, start_loc, toks[-1].end, "Syntax Error: Unclosed Curly Brace in static-block");
		}
		end_loc := chop_tok().end;

		if (!toks[idx-1].is("RCurly")) { stop("parseStaticBlock: end assumption broken"); }
		global.pop();
		return astNode("Static", start_loc, end_loc, om, stmts);
	};

	parseScan := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseScan` is not yet implemented");
	};

	parseFor := procedure() {
		global.push("parseFor");
		for_form := "for (<var> in <collection>) { <body> }";
		if (!toks[idx-1].is("For")) { stop("parseFor: start assumption broken"); }
		start_loc := toks[idx-1].start;

		if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: For-Satements should have the following form: " + for_form); }
		var := parsePrimary(chop_tok());
		if (!chop_tok().is("In")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: For-Satements should have the following form: " + for_form); }
		collection := parseExprWithEndTok(chop_tok(), ["RParan"]);
		if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: For-Satements should have the following form: " + for_form); }

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in For-statement");
		}

		next := chop_tok();
		end_loc := next.end;
		if (!toks[idx-1].is("RCurly")) { stop("parseFor: end assumption broken"); }
		global.pop();
		return astNode("For", start_loc, end_loc, om, [var, collection], body);
	};

	parseWhile := procedure() {
		global.push("parseWhile");
		while_form := "while (<cond>) { <body> }";
		if (!toks[idx-1].is("While")) { stop("parseWhile: start assumption broken"); }
		start_loc := toks[idx-1].start;

		if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: While-Satements should have the following form: " + while_form); }
		cond := parseExprWithEndTok(chop_tok(), ["RParan"]);
		if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: While-Satements should have the following form: " + while_form); }

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in While-statement");
		}

		next := chop_tok();
		end_loc := next.end;
		if (!toks[idx-1].is("RCurly")) { stop("parseWhile: end assumption broken"); }
		global.pop();
		return astNode("While", start_loc, end_loc, om, [cond], body);
	};

	parseDoWhile := procedure() {
		global.push("parseDoWhile");
		dowhile_form := "do { <body> } while (<cond>);";
		if (!toks[idx-1].is("Do")) { stop("parseDoWhile: start assumption broken"); }
		start_loc := toks[idx-1].start;

		if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: DoWhile-Satements should have the following form: " + dowhile_form); }
		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in DoWhile-statement");
		}

		if (!chop_tok().is("While")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: DoWhile-Satements should have the following form: " + dowhile_form); }
		if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: DoWhile-Satements should have the following form: " + dowhile_form); }
		cond := parseExprWithEndTok(chop_tok(), ["RParan"]);
		if (!chop_tok().is("SemiColon")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: DoWhile-Satements should have the following form: " + dowhile_form); }

		end_loc := toks[idx-1].end;
		global.pop();
		return astNode("DoWhile", start_loc, end_loc, om, [cond], body);
	};

	parseCheck := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseCheck` is not yet implemented");
	};

	parseBacktrack := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseBacktrack` is not yet implemented");
	};

	// Call with the cur_tok() equal to the bginning of the first comma-separated element
	// Returns with cur_tok() equal to the token after endTokType
	// parsingF should have the following signature: (token, [..endTokTypes])
	parseCommaSeparated := procedure(endTokType, parsingF := "exprOrAssign") {
		global.push("parseCommaSeparated", [["endTokType", endTokType], ["parsingF", parsingF]]);
		if (toks[idx-1].type notin {"LCurly", "LBrack", "LParan"}) { stop("parseCommaSeparated: start assumption broken"); }

		start_loc := cur_tok().start; // For error message
		res := [];
		do {
			if (idx > len) {
				compileErr(file, start_loc, toks[-1].end, "Unexpected End of File. Expected " + endTokType.displayStr() + " at the end of this comma-separated list");
			}
			t := chop_tok();
			if (t.is(endTokType)) {
				break;
			}
			x := om;
			if (parsingF == "exprOrAssign") { x := parseExprOrAssignWithEndTok(t, ["Comma", endTokType]); }
			else if (parsingF == "collectionOrPrimary") { x := parseCollectionOrPrimary(t, ["Comma", endTokType]); }
			else { throw("Unexpected input for parseCommaSeparated. parsingF is not expected to be '" + parsingF + "'"); }
			res += [x];
		} while (!toks[idx-1].is(endTokType));

		if (!toks[idx-1].is(endTokType)) { stop("parseCommaSeparated: end assumption broken"); }
		global.pop();
		return res;
	};

	// Call with cur_tok() equal to the first element in parantheses
	// Returns with cur_tok() equal to the token after the closing parantheses
	parseParan := procedure() {
		global.push("parseParan");
		if (!toks[idx-1].is("LParan")) { stop("parseParan: start assumption borken"); }

		t := toks[idx-1];
		res := parseExprWithEndTok(chop_tok(), ["RParan"]);
		res.start := t.start;
		res.end := toks[idx-1].end;

		if (res.end != toks[idx-1].end) { stop("parseParan: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with t == toks[idx-1]
	// Ends with toks[idx-1] in endTokTypes
	// Parses Collections or Ranges
	parseCollectionOrPrimary := procedure(t := chop_tok(), endTokTypes := ["Comma"]) {
		global.push("parseCollectionOrPrimary", [["t", t.toStr()], ["endTokTypes", listToStr(endTokTypes)]]);
		if (toks[idx-1] != t) { stop("parseCollectionOrPrimary: start assumption broken"); }

		res := om;
		switch {
			case t.is("LBrack"): res := parseList();
			case t.is("LCurly"): res := parseSet();
			default:
				res := parseExprWithEndTok(t, endTokTypes + ["DotDot"]);
				if (toks[idx-1].is("DotDot")) {
					x := om;
					if (cur_tok() notin endTokTypes) { x := parseExprWithEndTok(chop_tok(), endTokTypes); }
					else { chop_tok(); }
					res := astNode("Range", res.start, toks[idx-1].end, om, [res, x]);
				}
				this.idx -= 1;
		}
		if (chop_tok().type notin endTokTypes) {
			tt := toks[idx-1];
			compileErr(file, tt.start, tt.end, "Unexpected Token " + tt.displayStr() + ". Expected a " + join(endTokTypes, " or ") + " instead");
		}

		if (toks[idx-1].type notin endTokTypes) { stop("parseCollectionOrPrimary: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with toks[idx-1] == "{"
	// Ends with toks[idx-1] == "}"
	parseSet := procedure() {
		global.push("parseSet");
		if (!toks[idx-1].is("LCurly")) { stop("parseSet: start assumption broken"); }

		start_loc := toks[idx-1].start;
		items := parseCommaSeparated("RCurly", "collectionOrPrimary");

		if (!toks[idx-1].is("RCurly")) { stop("parseSet: end assumption broken"); }
		global.pop();
		return astNode("Set", start_loc, toks[idx-1].end, om, items);
	};

	// Starts with toks[idx-1] == "["
	// Ends with toks[idx-1] == "]"
	parseList := procedure() {
		global.push("parseList");
		if (!toks[idx-1].is("LBrack")) { stop("parseList: start assumption broken"); }

		start_loc := toks[idx-1].start;
		items := parseCommaSeparated("RBrack", "collectionOrPrimary");
		if (!toks[idx-1].is("RBrack")) { stop("parseList: end assumption broken"); }
		global.pop();
		return astNode("List", start_loc, toks[idx-1].end, om, items);
	};

	// Starts with t == toks[idx-1]
	// Ends with cur_tok() being the next token after the primary value
	// @Note: Primary means either a literal or a paranthesized expression
	parsePrimary := procedure(t := chop_tok()) {
		global.push("parsePrimary", [["t", t.toStr()]]);
		if (toks[idx-1] != t) {
			global.p("t: " + t.displayStr());
			global.p("toks[idx-1]: " + toks[idx-1].displayStr());
			stop("parsePrimary: start assumption broken");
		}

		res := om;
		switch {
			case t.className == "astNode": res := t;
			case t.is("LParan"): res := parseParan();
			case t.is("LCurly"): res := parseSet();
			case t.is("LBrack"): res := parseList();
			case t.is("Str"): res := astNode("Str", t.start, t.end, t.data);
			case t.is("Int"): res := astNode("Int", t.start, t.end, t.data);
			case t.is("Float"): res := astNode("Float", t.start, t.end, t.data);
			case t.is("Iden"): res := astNode("Iden", t.start, t.end, t.data);
			default:
				if (!t.isPrimary()) {
					printErr("parsePrimary should only fail if the token isn't a primary. The token " + t.toStr() + " is apparently a primary though.");
				}
				compileErr(file, t.start, t.end, "Expected to parse a primary. Received '" + t.toStr() + "' instead");
		}

		if (toks[idx-1].end != res.end) { stop("parsePrimary: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with cur_tok() being the unary operator
	// Ends with cur_tok() being the token after the expression
	parseUnary := procedure() {
		global.push("parseUnary");
		if (cur_tok().type notin global.unaryOps) { stop("parseUnary: start assumption broken"); }

		unaryTok := chop_tok();
		expr := parsePrimary();

		if (expr.end != toks[idx-1].end) { stop("parseUnary: end assumption broken"); }
		global.pop();
		return astNode(unaryTok.type, unaryTok.start, expr.end, om, [expr]);
	};

	// Starts with cur_tok() being the token after lhs
	// Ends with cur_tok() being the token after the result
	parseBinOps := procedure(lhs, min_prec := 0) {
		global.push("parseBinOps", [["lhs", lhs.toStr()], ["min_prec", min_prec]]);
		if (lhs.end != toks[idx-1].end) { stop("parseBinOps: start assumption broken"); }

		lookahead := cur_tok();
		while (lookahead != om && global.binOpPrecs[lookahead.type] != om && global.binOpPrecs[lookahead.type] >= min_prec) {
			if (lhs.className() == "token") { lhs := parsePrimary(lhs); }
			bin_op := chop_tok();
			prec := global.binOpPrecs[lookahead.type];
			rhs := parsePrimary();
			lookahead := cur_tok();
			if (lookahead != om) {
				next_prec := global.binOpPrecs[lookahead.type];
				while (next_prec != om && (next_prec > prec || (next_prec == prec &&  global.isRightAssoc(lookahead.type)))) {
					next_min_prec := prec;
					if (next_prec > prec) {
						next_min_prec += 1;
					}
					rhs := parseBinOps(rhs, next_min_prec);
					lookahead := cur_tok();
					if (lookahead == om) {
						break;
					}
					next_prec := global.binOpPrecs[lookahead.type];
				}
			}
			lhs := astNode("BinOp", lhs.start, rhs.end, bin_op.type, [lhs, rhs]);
		}

		if (lhs.end != toks[idx-1].end) { stop("parseBinOps: end assumption broken"); }
		global.pop();
		return lhs;
	};
}

simplifyAST := procedure(ast) {
	global.push("simplifyAST", [["ast", ast.toStr()]]);
	if (ast.className() == "token" || (ast.args == [] && ast.body == [])) { return ast; }
	if (ast.className() != "astNode") { throw("simplifyAST expects a token or astNode but received: " + ast); }

	res := om;
	switch {
		default: compileErr(ast.file, ast.start, ast.end, "Cannot simplify the following astNode: " + ast.displayStr());
	}
	global.pop();
	return res;
};

compile := procedure(file) {
	global.push("compile", [["file", file]]);
	str := join(readFile(file), "\n");
	toks := lexer(file, str).lex();

	fstr := readFile(file);
	// for(i in {1..#toks}) {
	// 	tok := toks[i];
	// 	if (tok.start.row != tok.end.row) { stop("broken assumption"); }
	// 	global.p(i + ": " + fstr[tok.start.row][tok.start.col..tok.end.col-1] + " = " + tok.displayStr() + " [" + tok.start.locStr() + " - " + tok.end.locStr() + "]");
	// }
	// print("Tokens:");
	// for (tok in toks) {
	// 	print(tok.displayStr() /* + " [" + tok.start.locStr() + " - " + tok.end.locStr() + "]" */ );
	// }

	// global.p("\n");

	ast := parser(file, toks).parse();
	print("AST:");
	print(ast.dumpToStr(false));
	global.pop();
};


main := procedure(params) {
	if (#params < 1) {
		printErr("Not enough arguments were provided.");
		printErr();
		printErr("Usage:");
		printErr("setlX setlXC.stlx -p <filename> [-d | -dd]");
		printErr("The flag '-d'  is optional and enables debugging mode.      It prints some useful debugging information.");
		printErr("The flag '-dd' is optional and enables full-debugging mode. It prints all debugging information, as well as all information that the interpreter has.");
		return;
	}

	fullDebug := false;
	if (#params >= 2 && params[2][..2] == "-d") {
		global.debug := true;
		if (params[2][3] == "d") { fullDebug := true; }
	}

	global.push("main", [["params", params]]);
	try {
		compile(params[1]);
	} catch (e) {
		printErr(e);
		if (global.debug) {
			print("\nStack:");
			print(global.stack.toStr());

			if (fullDebug) {
				print("Current Function:");
				print(global.stack.get(global.stacklen));
			}
		}
	}
};

main(params);