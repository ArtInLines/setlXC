class stackNode(n) {
	this.name := n;
	this.children := [];
	toStr := procedure(in_level := 0, in_str := "  ") {
		s := in_str * in_level;
		s += this.name;
		for (c in this.children) {
			s += "\n" + c.toStr(in_level + 1, in_str);
		}
		return s;
	};
	add := procedure(n, x := 0) {
		if (x <= 0) { this.children += [stackNode(n)]; }
		else if (this.children == []) { throw("Error in adding to stackNode"); }
		else { this.children[#children] := this.children[#children].add(n, x - 1); }
		return this;
	};
}

class global() {
	static {
		debug := false;
		p := procedure(s) {
			if (global.debug) { print(s); }
		};

		stack := om;
		stacklen := 0;
		push := procedure(name) {
			if (global.stack == om) { global.stack := stackNode(name); }
			else { global.stack := global.stack.add(name, global.stacklen - 1); }
			global.stacklen += 1;
		};
		pop := procedure() {
			global.stacklen -= 1;
		};

		keywordsToToks := {
			["class", "Class"],
			["static", "Static"],
			["in", "In"],
			["notin", "Notin"],
			["return", "Ret"],
			["procedure", "Proc"],
			["cachedProcedure", "CachedProc"],
			["try", "Try"],
			["catch", "Catch"],
			["if", "If"],
			["else", "Else"],
			["for", "For"],
			["while", "While"],
			["do", "Do"]
		};

		symbolsToToks := [
			["(", "LParan"],
			[")", "RParan"],
			["[", "LBrack"],
			["]", "RBrack"],
			["{", "LCurly"],
			["}", "RCurly"],
			["|->", "Lambda"],
			["|=>", "ScopedLambda"], // TODO: Rename
			["<==>", "Equiv"],
			["<!=>", "Xor"],
			["=>", "Entail"],
			["||", "Or"],
			["&&", "And"],
			[":=", "Assign"],
			["==", "Eq"],
			["!=", "Ne"],
			["<=", "Le"],
			[">=", "Ge"],
			["<", "Lt"],
			[">", "Gt"],
			["!", "Exclamation"],
			["**", "Exp"],
			["+/", "AddColl"],
			["*/", "MulColl"],
			["><", "CartProd"],
			["+=", "AddAssign"],
			["-=", "SubAssign"],
			["*=", "MulAssign"],
			["/=", "DivAssign"],
			["%=", "ModAssign"],
			['\=', "IntDivAssign"],
			["+", "Add"],
			["-", "Sub"],
			["*", "Mul"],
			["/", "Div"],
			["%", "Mod"],
			['\', "IntDiv"],
			["#", "Hash"],
			[",", "Comma"],
			[";", "SemiColon"],
			[":", "Colon"],
			["..", "DotDot"],
			[".", "Dot"]
		];

		assignToks := ["Assign", "AddAssign", "SubAssign", "MulAssign", "DivAssign", "ModAssign", "IntDivAssign"];

		unaryPrecs := ["+/", "*/"];

		// The higher the precedence, the earlier the operation is evaluated
		binOpPrecs := {
			["Equiv", 20],
			["Xor", 20],
			["Entail", 31],
			["Or", 32],
			["And", 33],
			["Le", 35],
			["Ge", 35],
			["Lt", 35],
			["Gt", 35],
			["In", 35],
			["Notin", 35],
			["Eq", 35],
			["Ne", 35],
			["Add", 40],
			["Sub", 40],
			["Mul", 50],
			["Div", 50],
			["Mod", 50],
			["IntDiv", 50],
			["CartProd", 50],
			["AddColl", 60],
			["MulColl", 60],
			["Exp", 90]
		};

		isRightAssoc := procedure(toktype) {
			return toktype in { "Exp", "Assign", "AddAssign", "SubAssign", "MulAssign", "DivAssign", "ModAssign", "IntDivAssign" };
		};
	}
}

class loc(file, row, col) {
	file := file;
	row := row;
	col := col;
	className := procedure() { return "loc"; };
	equals := procedure(other) { return other != om && file == other.file && row == other.row && col == other.col; };
	locStr := procedure() { return file + ":" + row + ":" + col; };

	static {
		toStr := procedure(start, end) {
			if (start.file != end.file) { throw("loc.toStr(start, end) doesn't work if `start` and `end` are locations in different files"); }
			lines := readFile(start.file, [start.row..end.row]);
			if (start.row == end.row) {
				lines[1] := lines[1][start.col..end.col];
			} else {
				lines[1] := lines[1][start.col..];
				lines[-1] := lines[-1][..end.col];
			}
			return join(lines, "\n");
		};
	}
}

class token(type, start, end, data := om) {
	type := type;
	start := start;
	end := end;
	data := data;
	className := procedure() { return "token"; };
	is := procedure(typ) { return type == typ; };
	isPrimary := procedure() { return type in {"Iden", "Str", "Int", "Float", "LParan", "LBrack", "LCurly", "Hash", "Ret"}; };
	equals := procedure(other) { return other != om && type == other.type && start == other.start && end == other.end && data == other.data; };
	displayStr := procedure() {
		if (data == om) {
			return type;
		} else {
			return type + "('" + data + "')";
		}
	};
}

class astNode(type, start, end, data := om, args := [], body := []) {
	type := type;
	start := start;
	end := end;
	data := data;
	args := args;
	body := body;
	className := procedure() { return "astNode"; };
	is := procedure(typ) { return type == typ; };
	equals := procedure(other) { return other != om && type == other.type && start == other.start && end == other.end && data == other.data; }; // Not checking children for equality for performance reasons
	dataToStr := procedure() {
		dat := data;
		if (data != om && isObject(data) && data.className() == "astNode") { dat := dat.displayStr(); }
		return dat;
	};
	dumpToStr := procedure(show_loc := false, indent_level := 0, single_indent := " ") {
		s := single_indent * indent_level + "@" + type;
		if (data != om) { s += "('" + dataToStr() + "')"; }
		if (show_loc) { s += " [" + start.locStr() + " - " + end.locStr() + "]"; }

		if (#args > 0 && #body > 0) { s += "\n" + single_indent * (indent_level + 1) + "Args:"; }
		for (c in args) { s += "\n" + c.dumpToStr(show_loc, indent_level + 2, single_indent); }
		if (#body > 0) { s += "\n" + single_indent * (indent_level + 1) + "Body:"; }
		for (stmt in body) { s += "\n" + stmt.dumpToStr(show_loc, indent_level + 2, single_indent); }
		return s;
	};
	displayStr := procedure() {
		if (data ==  om) {
			return "@" + type;
		}
		return "@" + type + "(" + dataToStr() + ")";
	}; // for compatibility with token-class
}



compileErr := procedure(file, start, endOrLocStr, msg) {
	printErr(msg + ":");
	locStr := endOrLocStr;
	if (isObject(endOrLocStr)) { locStr := loc.toStr(start, endOrLocStr); }
	printErr(start.locStr() + ": '" + locStr + "'");
	throw("Compiler Error");
};

startsWith := procedure(str, prefix, strOffset := 0) {
	if (#str - strOffset < #prefix) {
		return false;
	}
	for (i in {1..#prefix}) {
		if (str[strOffset + i] != prefix[i]) {
			return false;
		}
	}
	return true;
};

class lexer(file_path, str) {
	file := file_path;
	str := str;
	cur := 1;
	bol := 0;
	lc := 1;
	len := #str;
	className := procedure() { return "lexer"; };

	is_space := procedure(c := str[cur]) {
		return c == " " || c == "\t" || c == "\n" || c == "\r";
	};

	is_newline := procedure(c := str[cur]) {
		return c == "\n";
	};

	chop_char := procedure() {
		if (is_newline()) {
			this.bol := this.cur;
			this.lc += 1;
		}
		this.cur += 1;
	};

	chop_lc := procedure() {
		// Line Comment
		if(str[cur..cur+1] != "//") { throw("chop_lc should only be called when str[cur..cur+1] == '//' is true"); }
		this.cur += 2;
		while (cur <= len && !is_newline(str[cur])) {
			chop_char();
		}
	};

	chop_bc := procedure() {
		// Block Comment
		start_cur := cur;
		start := loc(file, lc,start_cur - bol);
		if(str[cur..cur+1] != "/*") { throw("chop_bc should only be called when str[cur..cur+1] == '/*' is true"); }
		this.cur += 2;
		while (cur <= len) {
			// Return from function, when block comment is over
			if (cur < len && str[cur..cur+1] == "*/") {
				this.cur += 2;
				return om;
			}
			chop_char();
		}
		compileErr(file, start, str[start_cur..cur], "Unclosed Block Comment");
	};

	next_word := procedure() {
		start := cur;
		s := str[cur];
		this.cur += 1;
		while (cur < len && matches(str[cur], '[a-zA-Z_0-9]')) {
			s += str[cur];
			chop_char();
		}

		start := loc(file, lc,start - bol);
		end := loc(file, lc,cur - bol);
		if (s in domain(global.keywordsToToks)) {
			return token(global.keywordsToToks[s], start, end);
		} else {
			return token("Iden", start, end, s);
		}
	};

	next_num := procedure() {
		start := cur;
		s := str[cur];
		this.cur += 1;
		isFloat := false;
		while (cur < len && matches(str[cur], '[0-9.]')) {
			if (str[cur] == '.') {
				// The dot is here to start a range, not to make a float
				if (str[cur+1] == '.') { break; }
				if (isFloat) { compileErr(file, loc(file, lc,start - bol), str[start..cur], "Only one '.' is allowed for numbers."); }
				isFloat := true;
			}
			s += str[cur];
			chop_char();
		}

		start := loc(file, lc,start - bol);
		end := loc(file, lc, cur - bol);
		if (isFloat) {
			return token("Float", start, end, s);
		} else {
			return token("Int", start, end, s);
		}
	};

	next_symbol := procedure() {
		start := cur;
		for([sym, tok] in global.symbolsToToks) {
			if (startsWith(str, sym, cur - 1)) {
				this.cur += #sym;
				return token(tok, loc(file, lc, start - bol), loc(file, lc, cur - bol));
			}
		}
		compileErr(file, loc(file, lc,start - bol), str[start], "Unknown Symbol");
	};

	next_str := procedure() {
		start := loc(file, lc,cur - bol);
		strDelim := str[cur];
		this.cur += 1;
		s := "";
		while (cur < len && str[cur] != strDelim) {
			if (strDelim == '"' && str[cur] == '\') {
				chop_char();
				if (cur > len) { break; }
				match (str[cur]) {
					// List of escape-chars: https://docs.oracle.com/javase/tutorial/java/data/characters.html
					regex 't': s += "\t";
					regex 'b': s += "\b";
					regex 'n': s += "\n";
					regex 'r': s += "\r";
					regex 'f': s += "\f";
					regex '"': s += '"';
					regex "'": s += "'";
					regex '\\': s += '\';
					default: return compileErr(file, start, s + '\' + str[cur], "Invalid Escape Character '" + str[cur] + "'");
				}
			} else {
				s += str[cur];
			}
			chop_char();
		}

		if (cur > len) {
			return compileErr(file, start, loc(file, lc,cur - bol), strDelim + s, "Unclosed String");
		}
		assert(str[cur] == strDelim, "At the end of the while-loop, it is expected that `str[cur] == strEnd` is true, unless the string is unclosed");
		chop_char();
		end := loc(file, lc,cur - bol);
		return token("Str", start, end, s);
	};

	next_token := procedure() {
		// global.p("next_token  -  cur=" + cur + ", str[cur]=" + str[cur]);
		while(cur <= len && is_space()) {
			chop_char();
		}
		if (cur > len) {
			return om;
		}
		if (matches(str[cur], '[a-zA-Z_]')) { return next_word();   }
		else if (matches(str[cur], '[0-9]')) { return next_num();    }
		else if (str[cur] == '"') { return next_str(); }
		else if (str[cur] == "'") { return next_str(); }
		else if (cur < len && str[cur..cur+1] == "//") {
			chop_lc();
			return next_token();
		}
		else if (cur < len && str[cur..cur+1] == "/*") {
			chop_bc();
			return next_token();
		}
		else { return next_symbol(); }
	};

	lex := procedure() {
		toks := [];
		t := next_token();
		while (t != om) {
			toks += [t];
			t := next_token();
		}
		return toks;
	};
}

class parser(file_path, toks) {
	file := file_path;
	toks := toks;
	len := #toks;
	idx := 1;
	className := procedure() { return "parser"; };

	cur_tok := procedure() {
		return toks[idx];
	};

	chop_tok := procedure() {
		if (idx > len) {
			compileErr(file, toks[-1].start, toks[-1].end, "Unexpected End of File.");
		}
		t := toks[idx];
		this.idx += 1;
		return t;
	};

	get_tok_prec := procedure() {
		if (toks[idx] in domain(global.binOpPrecs)) {
			return global.binOpPrecs[toks[idx]];
		} else {
			return -1;
		}
	};

	parse := procedure() {
		global.push("parse");
		if (len == 0) {
			return astNode("Block", 0, 0);
		}

		stmts := [];
		while (idx <= len) {
			stmts += [parseStmt({["Class", [] |=> parseClass()]})];
		}
		global.pop();
		return astNode("Block", toks[1].start, toks[-1].end, om, stmts);
	};

	parseStmt := procedure(additionalCases := {}, invalidCases := {}) {
		global.push("parseStmt");
		t := chop_tok();
		res := om;
		switch {
			case t.type in domain(invalidCases): res := compileErr(file, t.start, t.end, invalidCases[t.type]);
			case t.type in domain(additionalCases): res := additionalCases[t.type]();
			case t.is('If'): res := parseIf();
			case t.is('Else'): res := parseElse();
			case t.is('Match'): res := parseMatch();
			case t.is("Switch"): res := parseSwitch();
			case t.is("Try"): res := parseTry();
			case t.is("Scan"): res := parseScan();
			case t.is("For"): res := parseFor();
			case t.is("While"): res := parseWhile();
			case t.is("Do"): res := parseDoWhile();
			case t.is("Check"): res := parseCheck();
			case t.is("Backtrack"): res := parseBacktrack();
			case t.isPrimary():
				res := parsePrimaryStmt(t, "SemiColon");
			default: compileErr(file, t.start, t.end, "Invalid Token starting Statement: " + t.displayStr());
		}
		// global.p("parsed stmt: " + res.displayStr());
		global.pop();
		return res;
	};

	// Starts with first token of stmt or astNode
	// Ends after token of endTokTypes
	parsePrimaryStmt := procedure(t, endTokTypes) {
		global.push("parsePrimaryStmt");
		if (!isList(endTokTypes)) {
			endTokTypes := [endTokTypes];
		}
		if (idx > len) {
			compileErr(file, t.start, t.end, "Unexpected End of File. Expected a ';'");
		}
		nt := chop_tok();
		// global.p("primaryStmt - t: " + t.displayStr());
		// global.p("primaryStmt - nt: " + nt.displayStr());
		// global.p("primaryStmt - endTokTypes: " + endTokTypes);

		res := om;
		switch {
			case nt.type in endTokTypes:
				if (t.className() != "astNode") {
					this.idx -= 1;
					res := parsePrimary(t);
					this.idx += 1;
				} else {
					res := t;
				}
			case t.className() == "astNode" && t.is("Ret"):
				this.idx -= 1;
				res := t;
			case t.is("Proc"):
				res := parseProc(nt);
				this.idx += 1;
			case nt.type in global.assignToks:
				if (t.type notin {"Iden", "Index", "Property"}) {
					compileErr(file, t.start, nt.end, "Expected an identifier before assignment. Found a " + t.displayStr() + " instead");
				}
				if (t.className() == "token") {
					this.idx -= 1;
					t := parsePrimary(t);
					this.idx += 1;
				}
				val := parsePrimaryStmt(chop_tok(), endTokTypes);
				if (nt.type != "Assign") {
					bin_op_typ := nt.type[..-7]; // - #"Assign" - 1
					bin_op := astNode("BinOp", t.start, nt.end, bin_op_typ, [t, val]);
					res := astNode("Assign", t.start, toks[idx-1].end, om, [t, bin_op]);
				} else {
					res := astNode("Assign", t.start, toks[idx-1].end, om, [t, val]);
				}
			case nt.type in domain(global.binOpPrecs):
				this.idx -= 1;
				op_ast := parseBinOps(t, 0);
				if (idx > len) {
					compileErr(file, t.start, toks[-1].end, "Invalid End of File. Expected a ';'");
				}
				res := parsePrimaryStmt(op_ast, endTokTypes);
			case t.className() == "token" && t.isPrimary():
				this.idx -= 2;
				res := parsePrimaryStmt(parsePrimary(), endTokTypes);
			case t.className() == "astNode" && nt.is("LBrack"):
				stmt := parsePrimaryStmt(chop_tok(), ["RBrack", "DotDot"]);
				if (toks[idx-1].is("DotDot")) {
					x := om;
					if (!cur_tok().is("RBrack")) { x := parsePrimaryStmt(chop_tok(), ["RBrack"]); }
					else { chop_tok(); }
					stmt := astNode("Range", t.start, toks[idx-1].end, om, [t, x]);
				}
				node := astNode("Index", t.start, stmt.end, om, [t, stmt]);
				res := parsePrimaryStmt(node, endTokTypes);
			case nt.is("LParan"):
				argList := parseCommaSeparated("RParan");
				data := t;
				if (t.className() == "token") { data := t.data; }
				call := astNode("Call", t.start, toks[idx-1].end, data, argList);
				// global.p(call.dumpToStr(true));
				res := parsePrimaryStmt(call, endTokTypes);
			case nt.is("Dot"):
				tt := chop_tok();
				if (!tt.is("Iden")) { compileErr(file, tt.start, loc.toStr(t.start, tt.end), "Syntax Error. Only identifiers are allowed as accessors after a dot."); }
				tt := parsePrimary(tt);
				p := t.data;
				if (t.className() == "astNode") { p := t; }
				prop := astNode("Property", t.start, tt.end, t.data, [tt]);
				res := parsePrimaryStmt(prop, endTokTypes);
			default:
				global.p("endTokTypes: " + endTokTypes);
				global.p("t.loc: " + t.start.locStr() + " - " + t.end.locStr());
				global.p("nt.loc: " + nt.start.locStr() + " - " + nt.end.locStr());
				compileErr(file, t.start, nt.end, "Unhandled case for initial token " + t.displayStr() + " and next token " + nt.displayStr() + ". This case was not implemented yet");
		}


		if (toks[idx-1].type notin endTokTypes) { stop("parsePrimaryStmt: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with toks[idx-2] == procedure & t == toks[idx-1]
	// End with toks[idx-1] == ending "}"
	parseProc := procedure(t := chop_tok()) {
		global.push("parseProc");
		if (!toks[idx-2].is("Proc") || t != toks[idx-1]) { stop("parseProc: start assumption broken"); }

		start_loc := toks[idx-2].start;
		proc_format := "'procedure ( <argument>* ) { <body> }'";
		if (!t.is("LParan")) {
			compileErr(file, t.start, loc.toStr(start_loc, t.end), "Syntax Error. Procedure-Definitions should have the following format: " + proc_format);
		}
		argList := parseCommaSeparated("RParan");
		tt := chop_tok();
		if (!tt.is("LCurly")) {
			compileErr(file, tt.start, loc.toStr(start_loc, tt.end), "Syntax Error. Procedure-Definitions should have the following format: " + proc_format);
		}

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}

		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Syntax Error. Procedure-Definitions should have the following format: " + proc_format);
		}
		end_loc := chop_tok().end;
		res := astNode("Proc", start_loc, end_loc, om, argList, body);

		// global.p("parsed proc:\n" + res.dumpToStr(1));
		if (!toks[idx-1].is("RCurly")) { stop("parseProc: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with toks[idx-1] == "if"
	// Ends with toks[idx-1] == "}"
	parseIf := procedure() {
		global.push("parseIf");
		if_form := "if (<cond>) { <body> }";
		if (!toks[idx-1].is("If")) { stop("parseIf: start assumption broken"); }
		start_loc := toks[idx-1].start;

		if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: If-Satements should have the following form: " + if_form); }
		cond := parsePrimaryStmt(chop_tok(), ["RParan"]);
		if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: If-Satements should have the following form: " + if_form); }

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in If-statement");
		}

		next := chop_tok();
		end_loc := next.end;
		if (!toks[idx-1].is("RCurly")) { stop("parseIf: end assumption broken"); }
		global.pop();
		return astNode("If", start_loc, end_loc, om, [cond], body);
	};

	// Starts with toks[idx-1] == "Else"
	// Ends with toks[idx-1] == "}"
	parseElse := procedure() {
		global.push("parseElse");
		else_form := "else (if (<cond>))* { <body> }";
		if (!toks[idx-1].is("Else")) { stop("parseElse: start assumption broken"); }
		start_loc := toks[idx-1].start;

		conds := [];
		if (cur_tok().is("If")) {
			chop_tok();
			if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: Else-Satements should have the following form: " + else_form); }
			conds += [parsePrimaryStmt(chop_tok(), ["RParan"])];
			if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: Else-Satements should have the following form: " + else_form); }
		}

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in Else-statement");
		}

		next := chop_tok();
		end_loc := next.end;
		if (!toks[idx-1].is("RCurly")) { stop("parseElse: end assumption broken"); }
		global.pop();
		return astNode("Else", start_loc, end_loc, om, conds, body);
	};

	parseMatch := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseMatch` is not yet implemented");
	};

	parseSwitch := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseSwitch` is not yet implemented");
	};

	parseTry := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseTry` is not yet implemented");
	};

	// Starts with toks[idx-1] == "Class"
	// Ends with toks[idx-1] == "}"
	parseClass := procedure() {
		global.push("parseClass");
		if (!toks[idx-1].is("Class")) { stop("parseClass: start assumption broken"); }

		start_loc := toks[idx-1].start;
		class_format := 'class <name> (<arg>*) { <attributes and methods> }';
		if (idx + 5 > len) {
			compileErr(file, toks[idx-1].start, toks[-1].end, "Invalid end of file. Class-Declarations should have the following format: " + class_format);
		}
		name := chop_tok();
		if (!chop_tok().is("LParan")) {
			compileErr(file, toks[idx-1].start, loc.toStr(file, name.start, cur_tok().start), "Syntax Error. Class-Declarations should have the following format: " + class_format);
		}
		argList := parseCommaSeparated("RParan");
		if (!chop_tok().is("LCurly")) {
			compileErr(file, toks[idx-1].start, loc.toStr(file, name.start, cur_tok().start), "Syntax Error. Class-Declarations should have the following format: " + class_format);
		}
		stmts := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			stmts += [parseStmt({["Static", [] |=> parseStaticBlock()]}, {["Class", "Class-Declarations inside of class declarations are not allowed"]})];
		}
		if (idx > len) {
			compileErr(file, toks[-1].end, "class " + class_name + "(...) {... ", "Unclosed Curly Braces in Declaration of '" + class_name + "' class");
		}
		end_loc := chop_tok().end;

		if (!toks[idx-1].is("RCurly")) { stop("parseclass: end assumption broken"); }
		global.pop();
		return astNode("Class", start_loc, end_loc, class_name, argList, stmts);
	};

	// Call with toks[idx-1] == "Static"
	// Ends with toks[idx-1] == "}"
	parseStaticBlock := procedure() {
		global.push("parseStaticBlock");
		if (!toks[idx-1].is("Static")) { stop("parseStaticBlock: start assumption broken"); }

		start_loc := toks[idx-1].start;
		if (idx > len || !chop_tok().is("LCurly")) {
			compileErr(file, start_loc, "static", "Syntax Error: Expected '{ ... }' after `static` keyword.");
		}
		stmts := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			stmts += [parseStmt({}, {["Class", "Class-Declarations inside of class declarations are not allowed"]})];
		}
		if (idx > len){
			compileErr(file, start_loc, toks[-1].end, "Syntax Error: Unclosed Curly Brace in static-block");
		}
		end_loc := chop_tok().end;

		if (!toks[idx-1].is("RCurly")) { stop("parseStaticBlock: end assumption broken"); }
		global.pop();
		return astNode("Static", start_loc, end_loc, om, stmts);
	};

	parseScan := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseScan` is not yet implemented");
	};

	parseFor := procedure() {
		global.push("parseFor");
		for_form := "for (<var> in <collection>) { <body> }";
		if (!toks[idx-1].is("For")) { stop("parseFor: start assumption broken"); }
		start_loc := toks[idx-1].start;

		if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: For-Satements should have the following form: " + for_form); }
		var := parsePrimary(chop_tok());
		if (!chop_tok().is("In")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: For-Satements should have the following form: " + for_form); }
		collection := parsePrimaryStmt(chop_tok(), ["RParan"]);
		if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: For-Satements should have the following form: " + for_form); }

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in For-statement");
		}

		next := chop_tok();
		end_loc := next.end;
		if (!toks[idx-1].is("RCurly")) { stop("parseFor: end assumption broken"); }
		global.pop();
		return astNode("For", start_loc, end_loc, om, [var, collection], body);
	};

	parseWhile := procedure() {
		global.push("parseWhile");
		while_form := "while (<cond>) { <body> }";
		if (!toks[idx-1].is("While")) { stop("parseWhile: start assumption broken"); }
		start_loc := toks[idx-1].start;

		if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: While-Satements should have the following form: " + while_form); }
		cond := parsePrimaryStmt(chop_tok(), ["RParan"]);
		if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: While-Satements should have the following form: " + while_form); }

		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in While-statement");
		}

		next := chop_tok();
		end_loc := next.end;
		if (!toks[idx-1].is("RCurly")) { stop("parseWhile: end assumption broken"); }
		global.pop();
		return astNode("While", start_loc, end_loc, om, [cond], body);
	};

	parseDoWhile := procedure() {
		global.push("parseDoWhile");
		dowhile_form := "do { <body> } while (<cond>);";
		if (!toks[idx-1].is("Do")) { stop("parseDoWhile: start assumption broken"); }
		start_loc := toks[idx-1].start;

		if (!chop_tok().is("LCurly")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: DoWhile-Satements should have the following form: " + dowhile_form); }
		body := [];
		while (idx <= len && !cur_tok().is("RCurly")) {
			body += [parseStmt()];
		}
		if (idx > len) {
			compileErr(file, start_loc, toks[-1].end, "Unclosed Curly Braces in DoWhile-statement");
		}

		if (!chop_tok().is("While")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: DoWhile-Satements should have the following form: " + dowhile_form); }
		if (!chop_tok().is("LParan")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: DoWhile-Satements should have the following form: " + dowhile_form); }
		cond := parsePrimaryStmt(chop_tok(), ["RParan"]);
		if (!chop_tok().is("SemiColon")) { compileErr(file, start_loc, toks[idx-1].end, "Syntax Error: DoWhile-Satements should have the following form: " + dowhile_form); }

		end_loc := toks[idx-1].end;
		global.pop();
		return astNode("DoWhile", start_loc, end_loc, om, [cond], body);
	};

	parseCheck := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseCheck` is not yet implemented");
	};

	parseBacktrack := procedure() {
		t := cur_tok();
		compileErr(file, t.start, t.end, "`parseBacktrack` is not yet implemented");
	};

	// Call with the cur_tok() equal to the bginning of the first comma-separated element
	// Returns with cur_tok() equal to the token after endTokType
	// parsingF should have the following signature: (token, [..endTokTypes])
	parseCommaSeparated := procedure(endTokType, parsingF := "primaryStmt") {
		global.push("parseCommaSeparated");
		if (toks[idx-1].type notin {"LCurly", "LBrack", "LParan"}) { stop("parseCommaSeparated: start assumption broken"); }

		start_loc := cur_tok().start; // For error message
		res := [];
		do {
			if (idx > len) {
				compileErr(file, start_loc, toks[-1].end, "Unexpected End of File. Expected " + endTokType.displayStr() + " at the end of this comma-separated list");
			}
			t := chop_tok();
			if (t.is(endTokType)) {
				break;
			}
			x := om;
			if (parsingF == "primaryStmt") { x := parsePrimaryStmt(t, ["Comma", endTokType]); }
			else if (parsingF == "collectionOrPrimary") { x := parseCollectionOrPrimary(t, ["Comma", endTokType]); }
			else { throw("Unexpected input for parseCommaSeparated. parsingF is not expected to be '" + parsingF + "'"); }
			res += [x];
		} while (!toks[idx-1].is(endTokType));

		if (!toks[idx-1].is(endTokType)) { stop("parseCommaSeparated: end assumption broken"); }
		global.pop();
		return res;
	};

	parseParan := procedure() {
		t := toks[idx-1];
		compileErr(file, t.start, t.end, "`parseParan` is not yet implemented");
	};

	// Starts with t == toks[idx-1]
	// Ends with toks[idx-1] in endTokTypes
	// Parses Collections or Ranges
	parseCollectionOrPrimary := procedure(t := chop_tok(), endTokTypes := ["Comma"]) {
		global.push("parseCollectionOrPrimary");
		if (toks[idx-1] != t) { stop("parseCollectionOrPrimary: start assumption broken"); }

		res := om;
		switch {
			case t.is("LBrack"): res := parseList();
			case t.is("LCurly"): res := parseSet();
			default:
				res := parsePrimaryStmt(t, endTokTypes + ["DotDot"]);
				if (toks[idx-1].is("DotDot")) {
					x := om;
					if (cur_tok() notin endTokTypes) { x := parsePrimaryStmt(chop_tok(), endTokTypes); }
					else { chop_tok(); }
					res := astNode("Range", res.start, toks[idx-1].end, om, [res, x]);
				}
				this.idx -= 1;
		}
		if (chop_tok().type notin endTokTypes) {
			tt := toks[idx-1];
			compileErr(file, tt.start, tt.end, "Unexpected Token " + tt.displayStr() + ". Expected a " + join(endTokTypes, " or ") + " instead");
		}

		if (toks[idx-1].type notin endTokTypes) { stop("parseCollectionOrPrimary: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with toks[idx-1] == "{"
	// Ends with toks[idx-1] == "}"
	parseSet := procedure() {
		global.push("parseSet");
		if (!toks[idx-1].is("LCurly")) { stop("parseSet: start assumption broken"); }

		start_loc := toks[idx-1].start;
		items := parseCommaSeparated("RCurly", "collectionOrPrimary");

		if (!toks[idx-1].is("RCurly")) { stop("parseSet: end assumption broken"); }
		global.pop();
		return astNode("Set", start_loc, toks[idx-1].end, om, items);
	};

	// Starts with toks[idx-1] == "["
	// Ends with toks[idx-1] == "]"
	parseList := procedure() {
		global.push("parseList");
		if (!toks[idx-1].is("LBrack")) { stop("parseList: start assumption broken"); }

		start_loc := toks[idx-1].start;
		items := parseCommaSeparated("RBrack", "collectionOrPrimary");
		if (!toks[idx-1].is("RBrack")) { stop("parseList: end assumption broken"); }
		global.pop();
		return astNode("List", start_loc, toks[idx-1].end, om, items);
	};

	// Starts with t == toks[idx-1]
	// Ends with cur_tok() being the next token after the primary value
	parsePrimary := procedure(t := chop_tok()) {
		global.push("parsePrimary");
		if (toks[idx-1] != t) {
			global.p("t: " + t.displayStr());
			global.p("toks[idx-1]: " + toks[idx-1].displayStr());
			stop("parsePrimary: start assumption broken");
		}

		res := om;
		switch {
			case t.className == "astNode": res := t;
			case t.is("LParan"): res := parseParan();
			case t.is("LCurly"): res := parseSet();
			case t.is("LBrack"): res := parseList();
			case t.is("Str"): res := astNode("Str", t.start, t.end, t.data);
			case t.is("Int"): res := astNode("Int", t.start, t.end, t.data);
			case t.is("Float"): res := astNode("Float", t.start, t.end, t.data);
			case t.is("Iden"): res := astNode("Iden", t.start, t.end, t.data);
			case t.is("Hash"):
				if (idx > len) {
					compileErr(file, t.start, "#", "Invalid End of File. Expected a Statement after the hash-symbol");
				}
				el := parsePrimary();
				res := astNode("Len", t.start, toks[idx-1].end, om, [el]);
			case t.is("Ret"):
				if (idx > len) {
					compileErr(file, t.start, "return", "Invalid End of File. Expected a Statement or a Semicolon, but found nothing instead");
				}
				stmt := parsePrimaryStmt(chop_tok(), ["SemiColon"]);
				res := astNode("Ret", t.start, toks[idx-1].end, om, [stmt]);
			default:
				if (!t.isPrimary()) {
					printErr("parsePrimary should only fail if the token isn't primary. The token " + t + " is primary apparently though.");
				}
				compileErr(file, t.start, t.end, "Expected to parse a primary value. Received " + t.displayStr() + " instead");
		}

		if (toks[idx-1].end != res.end) { stop("parsePrimary: end assumption broken"); }
		global.pop();
		return res;
	};

	// Starts with cur_tok() being the token after lhs
	// Ends with cur_tok() being the token after the result
	parseBinOps := procedure(lhs, min_prec := 0) {
		global.push("parseBinOps");
		if (lhs.end != toks[idx-1].end) { stop("parseBinOps: start assumption broken"); }

		lookahead := cur_tok();
		while (lookahead != om && global.binOpPrecs[lookahead.type] != om && global.binOpPrecs[lookahead.type] >= min_prec) {
			if (lhs.className() == "token") { lhs := parsePrimary(lhs); }
			bin_op := chop_tok();
			prec := global.binOpPrecs[lookahead.type];
			rhs := parsePrimary();
			lookahead := cur_tok();
			if (lookahead != om) {
				next_prec := global.binOpPrecs[lookahead.type];
				while (next_prec != om && (next_prec > prec || (next_prec == prec &&  global.isRightAssoc(lookahead.type)))) {
					next_min_prec := prec;
					if (next_prec > prec) {
						next_min_prec += 1;
					}
					rhs := parseBinOps(rhs, next_min_prec);
					lookahead := cur_tok();
					if (lookahead == om) {
						break;
					}
					next_prec := global.binOpPrecs[lookahead.type];
				}
			}
			lhs := astNode("BinOp", lhs.start, rhs.end, bin_op.type, [lhs, rhs]);
		}

		if (lhs.end != toks[idx-1].end) { stop("parseBinOps: end assumption broken"); }
		global.pop();
		return lhs;
	};
}

simplifyAST := procedure(ast) {
	global.push("simplifyAST");
	if (ast.className() == "token" || (ast.args == [] && ast.body == [])) { return ast; }
	if (ast.className() != "astNode") { throw("simplifyAST expects a token or astNode but received: " + ast); }

	res := om;
	switch {
		default: compileErr(ast.file, ast.start, ast.end, "Cannot simplify the following astNode: " + ast.displayStr());
	}
	global.pop();
	return res;
};

compile := procedure(file) {
	global.push("compile");
	str := join(readFile(file), "\n");
	toks := lexer(file, str).lex();

	fstr := readFile(file);
	// for(i in {1..#toks}) {
	// 	tok := toks[i];
	// 	if (tok.start.row != tok.end.row) { stop("broken assumption"); }
	// 	global.p(i + ": " + fstr[tok.start.row][tok.start.col..tok.end.col-1] + " = " + tok.displayStr() + " [" + tok.start.locStr() + " - " + tok.end.locStr() + "]");
	// }
	// print("Tokens:");
	// for (tok in toks) {
	// 	print(tok.displayStr() /* + " [" + tok.start.locStr() + " - " + tok.end.locStr() + "]" */ );
	// }

	// global.p("\n");

	ast := parser(file, toks).parse();
	print("AST:");
	print(ast.dumpToStr(false));
	global.pop();
};


main := procedure(params) {
	if (#params < 1) {
		printErr("Not enough arguments were provided.");
		printErr();
		printErr("Usage:");
		printErr("setlX setlXC.stlx -p <filename> [-d]");
		printErr("The flag '-d' is optional and enables debugging mode. The only difference at the moment is that the full Stack-Trace is shown on errors if debugging mode is enabled.");
		return;
	}

	if (#params >= 2 && params[2] == "-d") {
		global.debug := true;
	}

	global.push("main");
	try {
		compile(params[1]);
	} catch (e) {
		printErr(e);
		if (global.debug) {
			print("\nStack:");
			print(global.stack.toStr());
		}
	}
};

main(params);